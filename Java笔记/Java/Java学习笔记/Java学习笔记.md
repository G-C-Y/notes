### 第一章 Java开发环境的搭建
#### 1、终端运行java
![image.png](https://images.cherryfloris.eu.org/2021/1627281790563-4a805c41-cff7-45d8-ab57-7aa887d502df.png)
#### 2、面向过程与面向对象的区别
由“如何把大象装进冰箱”来看：
**一、面向过程**
为了把大象装进冰箱，需要3个过程。
思路：
1、把冰箱门打开（得到打开门的冰箱）。
2、把大象装进去（打开门后，得到里面装着大象的冰箱）。
3、把冰箱门关上（打开门、装好大象后，获得关好门的冰箱)。
根据上面的思路，可以看到，每个过程都有一个阶段性的目标，依次完成这些过程，就能把大象装进冰箱。
**二、面向对象**
为了把大象装进冰箱，需要做三个动作（或者叫行为）。每个动作有一个执行者，它就是对象。
思路：
1、冰箱，你给我把门打开。
2、冰箱，你给我把大象装进去（或者说，大象，你给我钻到冰箱里去）。
3、冰箱，你给我把门关上。
依次完成这些动作，你就可以把大象装进去。
#### 3、JDK、JRE、JVM三者之间的关系？
**JDK:Java开发工具箱	**
**JRE:java运行环境**
**JVM:java虚拟机**
	JDK包括JRE，JRE包括JVM。JVM是不能独立安装的。JRE和JDK都是可以独立安装的。有单独的JDK安装包。也有单独的JRE安装包。没有单独的JVM安装包。
	安装JDK的时候：JRE就自动安装了，同时JRE内部的JVM也就自动安装了。
	安装JRE的时候：JVM也就自动安装了。
	问题：
		假设你在软件公司开发了一个新的软件，现在要去客户那边给客户把
		项目部署一下，把项目跑起来，你需要安装JDK吗？
			只需要安装JRE就行了。JRE体积很小，安装非常便捷快速。
	问题：
		为什么安装JDK的时候会自带一个JRE？
			因为java程序员开发完程序之后，要测试这个程序，让这个程序运行起来，需要JRE。所以JDK安装的时候内部自带一个JRE。
Java体系的技术被划分为三大块：		JavaSE：标准版       JavaEE：企业版      JavaME：微型版
#### 4、对Java的加载与执行的理解（理论比较重要）	
**java程序从编写到最终运行经历了哪些过程？？？？**
	java程序非常重要的两个阶段：
		编译阶段
		运行阶段
	注意：java程序员直接编写的java代码（普通文本）是无法执行被JVM识别的。java程序员编写的java代码这种普通文本必须经过一个编译，将这个“普通文本代码”变成“字节码”，JVM能够识别“字节码”。java代码这种普通文本变成字节码的过程，被称为：编译。java代码这种普通文本被称为：java源代码。（编写的代码是源代码）源代码不能直接执行，需要先进行编译，生成源代码对应的“字节码”JVM可以识别的是字节码。
	**编译阶段和运行阶段可以在不同的操作系统上完成吗？**
	在windows上编译，编译之后生成了“字节码”，把“字节码”放到linux上运行，完全可以，因为Java是跨平台的。可以做到一次编写到处运行。
	**java源代码一旦编译之后，源代码可以删除吗？只留下字节码可以执行吗？**
	完全可以执行，因为源代码不参与程序的执行过程。参与程序执行过程的是字节码。但是最好不要删除源代码。因为有可能执行结果不是你需要的，当执行结果不是你需要的时候，你可以重新打开源代码进行修改，然后重新编译生成新的字节码，再重新执行。这样会有新的执行效果。放源代码的文件扩展名必须是：xxx.java。并且需要注意的是：编译生成的字节码文件扩展名是：xxx.class
	.java文件就是源文件，这个文件中编写源代码。.class文件就是字节码文件，这个文件是编译源代码而得到的。另外需要注意的是：1个java源文件是可以编译生成多个class文件的。最终运行的是class文件。
	**问题：字节码文件是二进制文件吗？**
	字节码文件不是二进制文件。如果是二进制的话，就不需要JVM了。因为操作系统可以直接执行二进制。
**java程序从开发到最终运行经历了什么？**
	编译期：（可以在windows上）
	第一步：在硬盘的某个位置（随意），新建一个xxx.java文件
	第二步：使用记事本或者其它文本编辑器例如EditPlus打开xxx.java文件
	第三步：在xxx.java文件中编写“符合java语法规则的”源代码。
	第四步：保存（一定要将xxx.java文件保存一下）
	第五步：使用编译器（javac【JDK安装后自带】）对xxx.java文件进行编译。
	第六步：如果xxx.java文件中编写的源代码是符合语法规则的，编译会通过，如果xxx.java文件中编写的源代码违背了语法规则，那么编译器会报错，编译器报错之后class文件是不会生成的，只有编译通过了才会生成class字节码文件。并且一个java源文件是可以生成多个class文件的。（编译实质上是检查语法）
运行期（JRE在起作用）：（可以在windows上，也可以在其他的OS上。）
	第七步：如果是在Linux上运行，需要将windows上生成的class文件拷贝过去，不需要拷贝源代码，真正运行的是字节码。（但是源代码也不要删除，有用）
	第八步：使用JDK自带的一个命令/工具：java（负责运行的命令/工具）执行字节码
	第九步：往下的步骤就全部交给JVM了，就不需要程序员干涉了。JVM会将字节码文件装载进去，然后JVM对字节码进行解释（解释器负责将字节码解释为1010101010..等的二进制）
	第十步：JVM会将生成的二进制码交给OS操作系统，操作系统会执行二进制码和硬件进行交互。
	注意：在以上的过程中，需要使用两个非常重要的命令？
		javac 命令，负责编译         java 命令，负责运行
	小插曲：
		xxx.java源文件经过编译之后生成了A.class、B.class、C.class等文件，
		那么我们称A是一个类、B是一个类、C是一个类。其中A、B、C是类的名字。
		A/B/C是类的名称。A类、B类、C类。源文件中编写的代码叫做：源代码。
	以上是一个复杂的过程，那么缩减一下，程序员到底要干啥？
		新建java文件
  打开java文件
		写java源代码
		保存
		javac命令编译
		java命令运行
		编写、编译、运行
#### 5、编写java中的第一个java程序：HelloWorld（你好世界：问世）	
	主要是为了搭建java的开发环境，测试java的环境是否能用。
	第一步：安装文本编辑器（Eclipse）
	第二步：安装JDK（先下载JDK）
		JDK的bin目录下有：
			javac.exe 负责编译
			java.exe 负责运行
	第三步：写代码
		写一下第一个程序HelloWorld。
	第四步：编译
	第五步：运行
#### 6、开发第一个java程序：HelloWorld
	**1.1、程序写完之后，一定要ctrl + s 进行保存**
	java源代码只要修改，必须重新编译。重新编译生成新的class字节码文件。
	**1.2、编译阶段**
	配置环境变量path的步骤：桌面计算机上右键-->属性-->高级系统设置-->环境变量。怎么修改path环境变量？找到path，鼠标双击！！！！path环境变量当中都是路径，路径和路径之间必须采用“半角的分号”分隔。让javac.exe能用，我们配置哪个路径到path中？将C:\Program Files\Java\jdk-13.0.2\bin配置到path当中。
	**注意：环境变量包括“系统变量”和“用户变量”**
	系统变量：范围比较大，系统变量会让计算机所有用户都起作用。
	用户变量：范围比较小，这个变量只是作用于当前用户。
	怎么查看编译器版本？
 	C:\Users\Administrator>javac -version
		javac 13.0.2	
	怎么查看java虚拟机的版本？
		C:\Users\Administrator>java -version
		java version "13.0.2" 2020-01-14
		Java(TM) SE Runtime Environment (build 13.0.2+8)
		Java HotSpot(TM) 64-Bit Server VM (build 13.0.2+8, mixed mode, sharing)
	问题1：path环境变量的作用是什么？
		path环境变量的作用就是给windows操作系统指路的。告诉windows操作系统去哪里找这个命令文件。path环境变量中有很多很多的路径，路径和路径之间用半角分号分隔。path=A;B;C;D......Path是环境变量的名字。A;B;C;D......是环境变量path的值。
	问题2：path环境变量是java中的机制，还是windows操作系统中的机制？
	path环境变量是隶属于java的吗？path环境变量和java有关系吗？path环境变量本质上是隶属于windows操作系统的，和java没有关系。java只不过用了一下path环境变量。path环境变量中的路径可以指定多个，没问题，多少个都行。
	------------------------------------------------------------------------------
**	javac命令怎么用？**
	语法格式先背会：javac java源文件的路径
	什么是java源文件？java源文件的名字以“.java”结尾，该文件中写了java源代码。
	java源文件的路径是什么意思？注意：路径永远包括绝对路径和相对路径。
	注意：神操作？？？？把java源文件直接拖进到DOS命令窗口，那么DOS命令窗口就有这个路径了。
	C:\Users\Administrator>javac D:\course\JavaProjects\02-JavaSE\chapter01\HelloWorld.java
	D:\>javac course\JavaProjects\02-JavaSE\chapter01\HelloWorld.java
	D:\course\JavaProjects>javac 02-JavaSE\chapter01\HelloWorld.java
	D:\course\JavaProjects\02-JavaSE\chapter01>javac HelloWorld.java
	以上的四种方式都行，第一种方式是绝对路径剩下三种方式都是相对路径。
	注意：神操作？？？？
	怎么在DOS命令窗口中快速定位到某个路径呢？打开计算机-->打开一些文件夹-->在地址栏上直接输入cmd回车，这样直接就过去了。
**	1.3、运行阶段**
	运行的前提是：class文件（字节码）生成了。没有字节码文件程序是无法运行的。假设该文件的名字叫做：HelloWorld.class那么HelloWorld就是一个类名。如果文件名是Test.class，那么：Test就是一个类名。怎么运行，使用哪个命令？
	使用JDK的bin目录下的：java.exe命令来运行。先在DOS命令窗口中测试java.exe这个命令是否可用！！！java -version
	"java.exe"这个命令怎么用，语法格式是什么？java 类名
	java HelloWorld.class 对不对？不对！！正确的写法是：java HelloWorld
	千万千万要注意：java这个命令，后面跟的是“类名”，而绝对不能跟“文件路径”，
	因为java命令后面跟的不是文件，是一个“类名”。
	对于这个字节：Test.class	，应该：java Test。对于这个字节码：A.class ，应该 java A
运行java程序需要哪些步骤呢？
	第一步（必须这样做，这是必须的，先记住）：先使用cd命令切换到Test.class文件所在的路径。
第二步：执行java Test
![image.png](https://images.cherryfloris.eu.org/2021/1627436933076-87242cbe-d412-4ce3-a6c8-eca78e863b6d.png)

#### 7、我们一起来研究一下：“java HelloWorld”的执行过程以及原理。
	D:\course\JavaProjects\02-JavaSE\chapter01>java HelloWorld
	敲完回车，都发生了什么？？？？？
		第一步：会先启动JVM（java虚拟机）
		第二步：JVM启动之后，JVM会去启动“类加载器classloader”
		类加载器的作用：加载类的。本质上类加载器负责去硬盘上找“类”对应的“字节码”文件。
		假设是“java HelloWorld”，那么类加载器会去硬盘上搜索：HelloWorld.class文件。
		假设是“java Test”，那么类加载器会去硬盘上搜索：Test.class文件。
		.......
	
		第三步：
			类加载器如果在硬盘上找不到对应的字节码文件，会报错，报什么错？
				错误: 找不到或无法加载主类
			类加载器如果在硬盘上找到了对应的字节码文件，类加载器会将该字节码
			文件装载到JVM当中，JVM启动“解释器”将字节码解释为“101010000...”这种
			二进制码，操作系统执行二进制码和硬件交互。
	classpath环境变量的作用是什么？
		是给类加载器指路的。
		在没有配置环境变量classpath的时候，默认从当前路径下加载。
		如果配置了环境变量classpath的话，就只能从指定的路径下加载了。
	path java_home classpath，这3个环境变量path需要配置，后面两个暂时不配置。
#### 8、在高版本的JDK当中，直接一步到位：java x/y/z/xxx.java
	java后面直接加java源文件的路径。这个特性是为了简化开发而提出，但实际上底层的实现原理还是和以前一样的，以上命令在执行过程中，还是会先进行编译，然后再运行。并且以上的运行方式，编译生成的class文件在硬盘上不存在，看不到。
#### 9、注释！
	// 单行注释

	/*
		多行注释
	*/

	/**
	* javadoc注释：这里的注释信息可以自动被javadoc.exe命令解析提取并生成到帮助文档当中。
	*/
### 第二章  Java 的基本程序设计结构
#### 1、标识符	
 1.1、标识符可以标识什么，什么是标识符
  类名、接口名    变量名、方法名   常量名
	1.2、标识符的命名规则
	标识符只能由数字 字母(可以有中文) 下划线 美元符号组成，不能有其它符号。标识符不能以数字开始标识符严格区分大小写。关键字不能做标识符。理论上没有长度限制
	1.3、标识符的命名规范
见名知意，驼峰命名方式，一高一低。类名、接口名：首字母大写，后面每个单词首字母大写。变量名、方法名：首字母小写，后面每个单词首字母大写。常量名：全部大写，每个单词之间使用下划线衔接。标识符在editplus中是黑色字体。
	标准的**命名规范**为（类名 FirstSample 就遵循了这个规范）：类名是以大写字母开头的名词。如果名字由多个单词组成，每个单词的第一个字母都应该大写（这种在一个单词中间使用大写字母的方式称为胳蛇命名法。以其自身为例， 应该写成 CamelCase)。
**源代码的文件名**必须与公共类的名字相同，并用 .java 作为扩展名。因此，存储这段源代码的文件名必须为 FirstSample.java（大小写是非常重要的， 千万不能写成 firstsample.java）。
如果已经正确地命名了这个文件， 并且源代码中没有任何录人错误，在编译这段源代码之后就会得到一个包含这个类字节码的文件。Java 编译器将字节码文件自动地命名为FirstSample. class, 并与源文件存储在同一个目录下。
每个 **Java **应用程序都必须有一个 **main **方法，其声明格式如下所示： 
public class _ClassName _
{ 
public static void main(String[] args) 
**{ **
_program statements _
**} **
**} **
在 Java 中，每个句子必须用分号结束。 特别需要说明，回车不是语句的结束标志，因此，如果需要可以将一条语句写在多行上。
#### 2、关键字
	2.1、什么是关键字？
		在SUN公司开发Java语言的时候，提前定义好了一些具有特殊含义的单词，这些单词全部小写，具有特殊含义，不能用作标识符。
	2.2、凡是以蓝色字体形式存在的都是关键字，具有特殊含义。
	2.3、java语言中的所有关键字都是全部小写。
注意：java语言中是严格区分大小写的。public和Public不一样。Class和class不一样。static和Static也不一样。
	2.4、那么关键字有哪些呢，我们需要背会吗？需要单独去记忆吗？
		关键字：
			public 
			static
			void 
			class
			byte
			short
			int
			long 
			float
			double
			boolean
			char
			true
			false
			if
			while
			for
			private
			protected
			........
	**关键字 public **称为访问修饰符（access modifier), 这些修饰符用于控制程序的其他部分对这段代码的访问级別。
**关键字 class **表明 Java 程序中的全部内容都包含在类中。这里， 只需要将类作为一个加载程序逻辑的容器，程序逻辑定义了应用程序的行为。
#### 3、变量
	**3.1、字面量**
		字面量就是数据数据就是字面量。是一个东西。
		10 100 123 ：整型
		1.34 3.14 2.0：浮点型
		true false ：布尔型
		'a' '国'：字符型
		"a" "abc"  "国" "中国"：字符串型
		10：整数，是一个数字
		"10"：它不是数字，是一个字符串，或者说，它属于“文字类”的。
	性质完全不同，在计算机中的对应的二进制码也是完全不同的。
**	3.2、变量**
变量就是一个存数据盒子。（盒子大小谁来决定啊？数据类型）在内存中的最基本的存储单元。存数据用的，而且这个数据是可变的，所以叫做变量。
	**变量的三要素？**
	数据类型、变量名、值  （值就是数据，就是字面量。）int i = 100; java中的变量必须先声明，再赋值才能访问（必须手动赋值。）int k; System.out.println(k); 这样是不行的。
	可以在一行上声明多个变量。
	声明和赋值可以分开，也可以一起做！int i;  i = 100; // 先声明再赋值    int k = 200; // 声明的同时赋值。在“同一个域”当中，变量名不能重名！但可以重新赋值!!!!!!
	{
		int i = 100;
		//double i = 2.0; // 重名了编译器会报错，不允许。
		i = 300; // 可以重新赋值。
	}
	一个大括号代表一个域。
	{A域
		{B域
			{C域
			}
		}
	}
	A域包括B域，B域包括C域。
	**变量的分类**
	在方法体当中声明的变量叫做局部变量。
	public static void m1(){
						//局部变量，方法执行结束之后内存释放。
						int k = 100;
						int i = 200;
					    }
				在方法体外以及类体内声明的变量叫做成员变量。
					public class T{
						public static void x(){
						}
						// 成员变量
						int i = 200;
					}
	**变量的作用域**
			出了大括号就不认识了。别的先别管。
			{
				int i = 100;
				{
					在这里可以访问i
				}
			}

			{
				在这里是无法访问i变量。
			}
变量名必须是一个以字母开头并由字母或数字构成的序列。需要注意，与大多数程序设 计语言相比，Java 中“ 字母” 和“ 数字” 的范围更大。字母包括 ’A’ ~ ’Z’、 ‘a’ ~ ‘z’、 或在某种语言中表示字母的任何 Unicode 字符。但 V 和 '©’ 这样的符号不能出现在变量名中，空格也不行。变量名中所有的字符都是有 意义的，并且大小写敏感。变M名的长度基本上没有限制。
声明一个变量之后，必须用赋值语句对变量进行显式初始化， 千万不要使用未初始化的变量。在 Java 中， 不区分变量的声明与定义。利用关键字 final 指示常量。关键字 final 表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上,常量名使用全大写。
使用关键字 static final设置一个类常量：某个常量可以在一个类中的多个方法中使用，通常将这些常量称为类常量。
类常量的定义位于 main 方法的外部。因此，在同一个类的其他方法中也可以使用这个常量。而且，如果一个常量被声明为 public，那么其他类的方法也可以使用这个常量。
#### 4、数据类型	
**	4.1、数据类型有什么用？**
		数据类型用来声明变量，程序在运行过程中根据不同的数据类型分配不同大小的空间。
		int i = 10;
		double d = 1.23;
		i变量和d变量类型不同，空间大小不同。
	**4.2、数据类型在java语言中包括两种：**
		第一种：基本数据类型
		基本数据类型又可以划分为4大类8小种：
				第一类：整数型
					byte,short,int,long （没有小数的）
				第二类：浮点型 
					float,double （带有小数的）
				第三类：布尔型
					boolean：只有两个值true和false，true表示真，false表示假
				第四类：字符型
					char：java中规定字符型字面量必须使用单引号括起来。属于文字。
		8小种：
				byte,short,int,long
				float,double
				boolean
				char
		第二种：引用数据类型
		字符串型String属于引用数据类型。String字符串不属于基本数据类型范畴。java中除了基本数据类型之外，剩下的都是引用数据类型。引用数据类型后期面向对象的时候才会接触。
	**4.3、8种基本数据类型中**
		整数型：byte short int long有什么区别？浮点型：float和double有什么区别？区别：占用的空间大小不同。
			类型			占用字节数量(byte)
			------------------------------------
			byte				1
			short			2
			int				4
			long				8
			float				4
			double			8
			boolean			1  (1byte的1或0，00000001(true)或00000000(false))
			char				2
**	4.4、byte类型的取值范围?	**	
		byte是 [-128 ~ 127] 共可以标识256个不同的数字。
		byte类型的最大值是怎么计算出来的？
			byte是1个字节，是8个比特位，所以byte可以存储的最大值是：
				01111111
		注意：在计算机当中，一个二进制位最左边的是符号位，当为0时表示正数，
		当为1时表示负数。所以byte类型最大值是：01111111
		那么是不是2的7次方-1呢？
			是不是：10000000（前边是一个二进制） - 1
		
		byte类型最大值是：2的7次方 - 1.

		有几个取值范围需要大家记住：
			(1个字节)byte: [-128 ~ 127]
			(2个字节)short:[-32768 ~ 32767] 可以表示65536个不同的数字
			(4个字节)int: [-2147483648 ~ 2147483647]
			(2个字节)char: [0~65535]  可以表示65536个不同的数字
			short和char实际上容量相同，不过char可以表示更大的数字。
			因为char表示的是文字，文件没有正负之分，所以char可以表示
			更大的数字。
	
**	4.5、对于8种基本数据类型来说：**
	其中byte,short,int,long,float,double,boolean，这7种类型计算机表示起来比较容易，因为他们都是数字。其中布尔类型只有两个值true和false，实际上true和false分别在C++中对应的是1和0，1为true，false为0。对于char类型来说计算机表示起来比较麻烦，因为char对应的是文字，每一个国家的文字不一样，文字不能直接通过“自然算法”转换成二进制。这个时候怎么办？字符编码诞生了。
	什么是字符编码？
	字符编码是人为的定义的一套转换表。在字符编码中规定了一系列的文字对应的二进制。字符编码其实本质上就是一本字典，该字段中描述了文字与二进制之间的对照关系。字符编码是人为规定的。（是某个计算机协会规定的。）字符编码涉及到编码和解码两个过程，编码和解码的时候必须采用同一套字符编码方式，不然就会出现乱码。
	**4.6、数值类型之间的转换**
 	在类型转换的时候需要遵循哪些规则？
	第一条：八种基本数据类型中，除 boolean 类型不能转换，剩下七种类型之间都可以
	进行转换；
	第二条：如果整数型字面量没有超出 byte,short,char 的取值范围，可以直接将其赋
	值给byte,short,char 类型的变量；
	第三条：小容量向大容量转换称为自动类型转换，容量从小到大的排序为：
	byte < short(char) < int < long < float < double，其中 short和 char 
	都占用两个字节，但是char 可以表示更大的正整数；
	第四条：大容量转换成小容量，称为强制类型转换，编写时必须添加“强制类型转换符”，
	但运行时可能出现精度损失，谨慎使用；
	第五条：byte,short,char 类型混合运算时，先各自转换成 int 类型再做运算；
	第六条：多种数据类型混合运算，各自先转换成容量最大的那一种再做运算；
#### 5、接收用户键盘输入
 java.util.Scanner s = new java.util.Scanner(System.in);	// 接收整数
	int i = s.nextInt()
	// 接收字符串
	String str = s.next();
#### 6、控制语句	
6.1、控制语句的出现可以让我们的程序具有逻辑性/条理性，可以使用控制语句来实现一个“业务”了。
       6.2、控制语句包括几类？
		3类：选择语句循环语句转向语句
	6.3、**选择语句也可以叫做分支语句**
		**if语句**
               四种写法。语法机制：
				if(布尔表达式){
				}
				
				if(布尔表达式){
				}else{
				}

				if(布尔表达式){
				}else if(布尔表达式){
				}else if(布尔表达式){
				}else if(布尔表达式){
				}else if(布尔表达式){
				}

				if(布尔表达式){
				}else if(布尔表达式){
				}else if(布尔表达式){
				}else if(布尔表达式){
				}else if(布尔表达式){
				}else{
				}

				if语句嵌套：
					if(布尔表达式){ //前提条件
						if(布尔表达式){
							if(布尔表达式){
							
							}else{
							
							}
						}
					}else{
					
					}
				
			执行原理：
				对于一个if语句来说，只要有1个分支执行，整个if语句结束。
				当布尔表达式的结果为true时，分支才会执行。
				分支当中只有一条java语句，大括号可以省略。
				带有else的可以保证肯定会有一个分支执行。
		**switch语句**
   		完整语法结构：				
  switch(值){ 
    //值允许是String、int，（byte,short,char可以自动转换int）
				case 值1: case 值x:
					java语句;
					break;
				case 值2:
					java语句;
					break;
				case 值3:
					java语句;
					break;
				default:
					java语句;
				}
	6.4、**循环语句**：主要循环反复的去执行某段特定的代码块
		**for循环**
		 for(初始化表达式;条件表达式;更新表达式){
					循环体;
				}

				for(int i = 0; i < 10; i++){
					System.out.println(i);
				}

			for循环执行原理：
				1、先执行初始化表达式，并且只执行1次。
				2、然后判断条件表达式
				3、如果为true，则执行循环体。
				4、循环体结束之后，执行更新表达式。
				5、继续判断条件，如果条件还是true，继续循环。
				6、直到条件为false，循环结束。
		**while循环**
		while(布尔表达式){				
循环体;
			}
			执行次数：0~N次。
		**do..while..循环**
		do{				
循环体;
			}while(布尔表达式);

			执行次数：1~N次。
	**6.5、转向语句**
		**break**
		默认情况下，终止离它最近的循环。当然，也可以通过标识符的方式，终止指定的循环。
			for(int i = 0; i < 10; i++){
				if(i == 5){
					break;
				}
				code1;
				code2;
				code3;
				code4;
				....
			}
		**continue**
		终止当前“本次”循环，直接跳入下一次循环继续执行。			
  for(int i = 0; i < 10; i++){
				if(i == 5){
					continue;
				}
				code1;
				code2;
				code3;
				code4;
				....
			}
		**return**

---

#### 7、方法
1、方法是什么？	
方法（英语单词：method）是可以完成某个特定功能的并且可以被重复利用的代码片段。		在C语言中，方法被称为“函数”。在java中不叫函数，叫做方法。
	你定义了一个/抽取了一个方法出来，而这个方法确无法完成某个功能，那么你抽取的这个方法毫无意义。一般一个方法就是一个“功能单元”。假设在以后的开发中，某个功能是可以独立抽取出来的，建议定义为方法，这样以后只要需要这个功能，那么直接调用这个方法即可，而不需要重复编写业务逻辑代码。
2、方法最难实现的是：根据业务怎么进行方法的抽取。
	方法的返回值类型定义为 什么？
	方法的名字叫什么？
	方法的形式参数列表定义为 什么？
	....
	一个方法就是一个独立的功能。
3、方法的定义
	[修饰符列表] 返回值类型 方法名(形式参数列表){
		方法体; 
	}
注意：
		[] 符号叫做中括号，以上中括号[]里面的内容表示不是必须的，是可选的。
		方法体由Java语句构成。
		方法定义之后需要去调用，不调用是不会执行的。
4、方法的每一个细节学习
	4.1、修饰符列表：修饰符列表不是必选项，是可选的。目前为止，大家统一写成：public static
	4.2、怎么理解返回值？
	第一：返回值类型可以是任何类型，只要是java中合法的数据类型就行，数据类型包括基本数据类型和引用数据类型，也就是说返回值类型可以是：byte short int long float double boolean char String......
	第二：什么是返回值？
	返回值一般指的是一个方法执行结束之后的结果。结果通常是一个数据，所以被称为“值”，而且还叫“返回值”。方法就是为了完成某个特定的功能，方法结束之后大部分情况下都是有一个结果的，而体现结果的一般
都是数据。数据得有类型。这就是返回值类型。
	main{
		// 调用a方法
		a();..如果a方法执行结束之后有返回值，这个返回值返回给main了。
	}
	a(){}
	方法执行结束之后的返回值实际上是给调用者了。谁调用就返回给谁。
第三：当一个方法执行结束不返回任何值的时候，返回值类型也不能空白，必须写上void关键字。所以void表示该方法执行结束后不返回任何结果。
	第四：如果返回值类型“不是void”，那么你在方法体执行结束的时候必须使用"return 值;"这样的语句来完成“值”的返回，如果没有“return 值;”这样的语句那么编译器会报错。
	return 值; 这样的语句作用是什么？作用是“返回值”，返回方法的执行结果。
第五：只要有“return”关键字的语句执行，当前方法必然结束。return只要执行，当前所在的方法结束，记住：不是整个程序结束。
	第六：如果返回值类型是void，那么在方法体当中不能有“return 值;”这样的语句。但是可以有“return;”语句。这个语句“return;”的作用就是用来终止当前方法的。
	第七：除了void之外，剩下的都必须有“return 值;”这样的语句。
	4.5、方法名只要是合法的标识符就行，首字母小写，后面每个单词首字母大写。见名知意。
	4.6、形式参数列表
简称：形参
	注意：形式参数列表中的每一个参数都是“局部变量”，方法结束之后内存释放。
	形参的个数是：0~N个。
	public static void sumInt(){}
	public static void sumInt(int x){}
public static void sumInt(int x, int y){}
	public static void sum(int a, int b, double d, String s){}
	形参有多个的话使用“逗号,”隔开。逗号是英文的。
	形参的数据类型起决定性作用，形参对应的变量名是随意的。
	4.3、方法体
由Java语句构成。java语句以“;”结尾。方法体当中编写的是业务逻辑代码，完成某个特定功能。在方法体中的代码遵循自上而下的顺序依次逐行执行。在方法体中处理业务逻辑代码的时候需要数据，数据来源就是这些形参。
	4.4、方法怎么调用？“类名.”什么时候可以省略？
		实际参数列表，简称实参。（调用方法时传递的实际数据。）
   类名.方法名(实际参数列表);
		实参和形参的关系是一一对应。
5、JVM的内存结构中三块比较重要的内存空间。
	方法区：
		存储代码片段，存储xxx.class字节码文件，这个空间是最先有数据的，
		类加载器首先将代码加载到这里。
	堆内存：
		后面讲（面向对象）
	栈内存：
		stack栈当中存储什么？
			每个方法执行时所需要的内存空间（局部变量）。
![image.png](https://images.cherryfloris.eu.org/2021/1627615843588-447b26ec-97de-488b-9f85-fc7bbc762352.png)
6、关于数据结构中的栈数据结构
	原则：
		后进先出
		先进后出
	栈数据结构相关的术语：
		栈帧：永远指向栈顶部的元素（栈顶元素具有活跃权。）
		栈顶元素
		栈底元素
		压栈，入栈，进栈，push
		弹栈，出栈，pop
7、分析程序运行过程中的内存变化
	方法只定义不调用是不会执行的。
	方法调用时：压栈 （在栈中给该方法分配空间）
	方法执行结束时：弹栈（将该方法占用的空间释放，局部变量的内存也释放。）
       8、方法重载overload
	8.1、什么情况下我们考虑使用方法重载机制？
		当功能相似的时候，建议将方法名定义为一致的，
		这样代码美观，又方便编程。
		注意：如果功能不相似，坚决要让方法名不一致。
	8.2、代码满足什么条件的时候构成了方法重载？
		条件1：在同一个类当中
		条件2：方法名相同
		条件3：形式参数列表不同（类型、个数、顺序）
		注意：
			方法重载和返回值类型无关，和修饰符列表无关。
	8.3、方法重载的优点？
		代码美观，方便代码的编写
       9、方法递归
	9.1、需要理解什么是方法递归？
		方法自身调用自身。
	9.2、使用递归的时候，必须添加结束条件，没有结束条件，会发生栈内存溢出错误。
		StackOverflowError
		原因：一直压栈，没有弹栈，栈内存不够用。
	9.3、会画出递归方法的内存结构图。
		递归的过程当中可以将图画出来。
	9.4、能够使用循环代替递归的尽量使用循环，循环的执行耗费内存少一些，递归耗费内存相对多一些，另外递归使用不当很容易内存溢出，JVM停止工作。当然，只有极少数情况下，只能用递归，其它代码解决不了问题。
	9.5、当递归有结束条件，并且结束条件合法的时候，就一定不会内存溢出吗？
		也不一定。可能递归的太深了。
	9.6、分享了一些递归方面的经验
		在实际的开发中遇到递归导致的栈内存溢出错误是怎么办？
			第一步：先检查结束条件是否正确。
			第二步：如果正确，可以调整JVM的栈内存大小。(java -X)
10、我们要一味地将变量缩减吗？代码缩减吗？这样好吗？
	public class Test{
		public static void main(String[] args){
			/*
			int i = 100;
			System.out.println(i);
			*/

			System.out.println(100);

			boolean flag = test();
			if(flag){
				...
			}

			// 缩减之后的
			if(test()){
				....
			}
		}

		public static boolean test(){
			return true;
		}
	}

	太计较变量的数量会有什么后果呢？（运行效率不会低）
		后果1：代码的可读性差。
		后果2：可读性差也可以会牵连到代码的开发效率。
		其实计算机内存不差这个。。。。。。
		注意：在编码过程中，有一些变量名是必须要定义的。因为在后面代码中还需要访问这个数据。重复的访问这个数据。
#### 8、类与对象
**1、面向过程和面向对象有什么区别？**
	从语言方面出发：
		对于C语言来说，是完全面向过程的。
		对于C++语言来说，是一半面向过程，一半是面向对象。（C++是半面向对象的）
		对于Java语言来说，是完全面向对象的。
	什么是面向过程的开发方式？
		面向过程的开发方式主要的特点是：
			注重步骤，注重的是实现这个功能的步骤。
			第一步干什么
			第二步干什么
			....
			另外面向过程也注重实现功能的因果关系。
				因为A所有B
				因为B所以C
				因为C所以D
				.....
			面向过程中没有对象的概念。只是实现这个功能的步骤以及因果关系。		
	面向过程有什么缺点？（耦合度高，扩展力差。）
		面向过程最主要是每一步与每一步的因果关系，其中A步骤因果关系到B步骤，A和B联合起来形成一个子模块，子模块和子模块之间又因为因果关系结合在一起，假设其中任何一个因果关系出现问题（错误），此时
整个系统的运转都会出现问题。（代码和代码之间的耦合度太高，扩展力太差。）
		螺栓螺母拧在一起：耦合度高吗？这是耦合度低的，因为螺栓螺母可以再拧开。（它们之间是有接口的。）螺栓螺母拧在一起之后，再用焊条焊接在一起，耦合度高吗？这个耦合度就很高了。耦合度就是黏连程度。往往耦合度高的扩展力就差。耦合度高导致扩展力差。（集成显卡：计算机显卡不是独立的，是集成到主板上的）耦合度低导致扩展力强。（灯泡和灯口关系，螺栓螺母关系）
	采用面向过程的方式开发一台计算机会是怎样？
		这台计算机将没有任何一个部件，所有的都是融合在一起的。你的这台计算机是一个实心儿的，没有部件的。一体机。假设这台一体机的任何一个“部位”出问题，整个计算机就不能用了，必须扔掉了。（没有对象的概念。）
	采用面向对象的方式开发一台计算机会是怎样？内存条是一个对象主板是一个对象CPU是一个对象硬盘是一个对象，然后这些对象组装在一起，形成一台计算机。假设其中CPU坏了，我们可以将CPU拆下来，换一个新的。
	面向过程有什么优点？（快速开发）
		对于小型项目（功能），采用面向过程的方式进行开发，效率较高。不需要前期进行对象的提取，模型的建立，采用面向过程方式可以直接开始干活。一上来直接写代码，编写因果关系。从而实现功能。
	什么是面向对象的开发方式？
		采用面向对象的方式进行开发，更符合人类的思维方式。（面向对象成为主流的原因）人类就是以“对象”的方式去认识世界的。所以面向对象更容易让我们接受。面向对象就是将现实世界分割成不同的单元，然后每一个单元都实现成对象，然后给一个环境驱动一下，让各个对象之间协作起来形成一个系统。
		对象“张三”
		对象“香烟”
		对象“打火机”
		对象“吸烟的场所”
		然后将以上的4个对象组合在一起，就可以模拟一个人的抽烟场景。
		其中“张三”对象可以更换为“李四”
		其中“香烟”也可以更换品牌。
		其中“打火机”也可以更换。
		其中“吸烟的场所”也可以更换。
		采用面向对象的方式进行开发：耦合度低，扩展力强。
	找一个合适的案例。说明一下面向对象和面向过程的区别？
		蛋炒饭：
			鸡蛋和米饭完全混合在一起。没有独立对象的概念。假设客户提出新需求：我只想吃蛋炒饭中的米饭，怎么办？客户提出需求，软件开发者必须满足这个需求，于是开始扩展，这个软件的扩展是一场噩梦。（很难扩展，耦合度太高了。）
		盖饭：
			老板，来一份：鱼香肉丝盖饭鱼香肉丝是一道菜，可以看成一个独立的对象。米饭可以看成一个独立的对象。两个对象准备好之后，只要有一个动作，叫做：“盖”这样两个对象就组合在一起了。
		假设客户提出新需求：我不想吃鱼香肉丝盖饭,想吃西红柿鸡蛋盖饭。这个扩展就很轻松了。直接把“鱼香肉丝”对象换成“西红柿鸡蛋”对象。
	面向过程主要关注的是：实现步骤以及整个过程。
	面向对象主要关注的是：对象A，对象B，对象C，然后对象ABC组合，或者CBA组合.....
**2、我们采用面向对象的方式贯穿整个系统的话，涉及到三个术语：	**
 OOA：面向对象分析
	OOD：面向对象设计
	OOP：面向对象编程
	整个软件开发的过程，都是采用OO进行贯穿的。
	实现一个软件的过程：
		分析(A) --> 设计(D) --> 编程(P)
	在软件公司当中，一般同事与同事之间聊天，有的时候会突然说出来一个英语单词。这种情况是很常见的。所以一些术语还是要知道的，不然会闹出笑话。
	leader 领导/经理/组长
	team 团队
	PM 项目经理（整个项目的监管人）Project Manager
	**3、面向对象包括三大特征**
	封装继承多态
	任何一个面向对象的编程语言都包括这三个特征
	例如：
		python也有封装 继承 多态。
		java也有封装 继承 多态。
		注意：java只是面向对象编程语言中的一种。
		除了java之外，还有其它很多很多的编程语言也是面向对象的。
**4、类和对象的概念**
	面向对象当中最主要“一词”是：对象。
	什么是类？
		类实际上在现实世界当中是不存在的，是一个抽象的概念。是一个模板。是我们人类大脑进行“思考、总结、抽象”的一个结果。(主要是因为人类的大脑不一般才有了类的概念。)类本质上是现实世界当中某些事物具有共同特征，将这些共同特征提取出来形成的概念就是一个“类”，“类”就是一个模板。明星是一个类
	什么是对象？
		对象是实际存在的个体。（真实存在的个体）
		宋小宝就是一个对象
		姚明就是一个对象
		刘德华就是一个对象
		....
		宋小宝、姚明、刘德华这3个对象都属于“明星”这个类。
	在java语言中，要想得到“对象”，必须先定义“类”，“对象”是通过“类”这个模板创造出来的。
		类就是一个模板：类中描述的是所有对象的“共同特征信息”对象就是通过类创建出的个体。	
	这几个术语你需要自己能够阐述出来：
		类：不存在的，人类大脑思考总结一个模板（这个模板当中描述了共同特征。）
		对象：实际存在的个体。
		实例：对象还有另一个名字叫做实例。
		实例化：通过类这个模板创建对象的过程，叫做：实例化。
		抽象：多个对象具有共同特征，进行思考总结抽取共同特征的过程。
		类 --【实例化】--> 对象(实例)
		对象 --【抽象】--> 类	
	类是一个模板，是描述共同特征的一个模板，那么共同特征包括什么呢？
		潘长江对象：
			名字：潘长江
			身高：165cm
			打篮球：非专业的，自己玩儿呢，无所谓了
			学习：考试80分
		姚明对象：
			名字：姚明
			身高：240cm
			打篮球：NBA专业球员，打篮球非常棒
			学习：考试100分
		共同特征包括哪些？
			名字、身高都属于名词（状态特征）
			打篮球、学习都属于动词（动作特征）
		
		类 = 属性 + 方法
		属性来源于：状态
		方法来源于：动作

		public class 明星类{
			//属性-->状态，多见于名词
			名字属性;
			身高属性;

			//方法-->动作，多见于动词
			打篮球方法(){
			
			}
			学习方法(){
			
			}
		}

		陈赓同学、何伟彬同学，他们俩有没有共同特征呢？
			有共同特征，就可以抽象一个类模板出来。
		
		可以定义一个学生类（Student）
		public class Student {
			// 属性
			// 姓名
			// 性别
			// 身高

			// 方法
			public .... sing(){
			
			}
			public .... dance(){
			
			}
			public .... study(){
			
			}
			....
		}
**5、思考：“java软件工程师”在开发中起到的一个作用是什么？**
	我们为什么要做软件开发？说的大一些是为了人民服务。解决现实生活当中的问题。软件开发既然是为了解决现实世界当中的问题，那么首先java软件必须能够模拟现实世界。其实软件是一个虚拟的世界。这个虚拟的世界需要和现实世界一一对应，这才叫模拟。
**6、类的定义**
	6.1、怎么定义一个类，语法格式是什么？
		[修饰符列表] class 类名 {
			//类体 = 属性 + 方法
			// 属性在代码上以“变量”的形式存在（描述状态）
			// 方法描述动作/行为
		}
		注意：修饰符列表可以省略。
	6.2、为什么属性是“以”变量的形式存在的？
		假设我们要描述一个学生：
			学生包括哪些属性：
				学号: 110
				姓名："张三"
				性别：'男' (true/false)
				住址："深圳宝安区"
		答案：是因为属性对应的是“数据”，数据在程序中只能放到变量中。
		结论：属性其实就是变量。
		变量的分类还记得吗？
			变量根据出现位置进行划分：
				方法体当中声明的变量：局部变量。
				方法体外声明的变量：成员变量。（这里的成员变量就是“属性”）
7、关于编译的过程
	按说应该先编译XueSheng.java，然后再编译XueShengTest.java  但是对于编译器来说，编译XueShengTest.java文件的时候，会自动找XueSheng.class，如果没有，会自动编译XueSheng.java文件，生成
XueSheng.class文件。
		第一种方式：	
			javac XueSheng.java
			javac XueShengTest.java
		第二种方式：
			javac XueShengTest.java
		第三种方式：
			javac *.java

8、在语法级别上是怎么完成对象创建的呢？
	类名 变量名 = new 类名();
	这样就完成了对象的创建。

9、什么是实例变量？
	对象又被称为实例。
	实例变量实际上就是：对象级别的变量。
	public class 明星类{
		double height;
	}
	身高这个属性所有的明星对象都有，但是每一个对象都有“自己的身高值”。
	假设创建10个明星对象，height变量应该有10份。
	所以这种变量被称为对象级别的变量。属于实例变量。
	实例变量在访问的时候，是不是必须先创建对象？

10、对象和引用的区别？
	对象是通过new出来的，在堆内存中存储。
	引用是：但凡是变量，并且该变量中保存了内存地址指向了堆内存当中的对象的。

11、画内存图注意事项：
![image.png](https://images.cherryfloris.eu.org/2021/1627636926397-12b0eaa6-8ce5-4d87-bb73-7dabba22da58.png)
	第一：在内存图上不要体现出代码。内存上应该主要体现“数据”。
	第二：画图的时候，图上的图形应该有先后顺序，先画什么，再画什么，必须是有顺序的，而不是想起来这个画这个，想起来那个画那个。程序代码是有执行顺序的，程序执行到哪里你就画哪里就行了。
12、为什么要画内存图（非常重要）？
	第一：有了内存图，程序不运行，我也知道结果。（可以推算出结果）
	第二：有了内存图，有助于你调试程序。
	画内存图是对Java运行机制的一种理解。不知道运行机制，以后复杂的程序出现错误之后是不会调试的，调不明白。
**13、空指针异常。（NullPointerException）**
	关于垃圾回收器：GC
	在java语言中，垃圾回收器主要针对的是堆内存。当一个java对象没有任何引用指向该对象的时候，GC会考虑将该垃圾数据释放回收掉。
	出现空指针异常的前提条件是？
	"空引用"访问实例【对象相关】相关的数据时，都会出现空指针异常。
  空指针异常导致的最本质的原因是？	
  空引用访问“实例相关的数据”，会出现空指针异常。
	实例相关的包括：实例变量 + 实例方法。
14、方法在调用的时候参数是如何传递的？
	实际上，在java语言中，方法调用时参数传递，和类型无关，都是将变量中保存的那个“值”传过去，这个“值”可能是一个数字100，也可能是一个java对象的内存地址：0x1234
	不管是哪一种数据类型的传递，都是将“变量中保存的那个值复制一份传递过去。”
15、构造方法。
	15.1、当一个类中没有提供任何构造方法，系统默认提供一个无参数的构造方法。
	这个无参数的构造方法叫做缺省构造器。
	15.2、当一个类中手动的提供了构造方法，那么系统将不再默认提供无参数构造方法。建议将无参数构造方法手动的写出来，这样一定不会出问题。
	15.3、无参数构造方法和有参数的构造方法都可以调用。
		Student x = new Student();
		Student y = new Student(123);	
	15.4、构造方法支持方法重载吗？
		构造方法是支持方法重载的。
		在一个类当中构造方法可以有多个。
		并且所有的构造方法名字都是一样的。
		方法重载特点：
			在同一个类中，方法名相同，参数列表不同。
	15.5、对于实例变量来说，只要你在构造方法中没有手动给它赋值，统一都会默认赋值。默认赋系统值。
	构造方法需要掌握的知识点：
		1.构造方法有什么作用？
		2.构造方法怎么定义，语法是什么？
		3.构造方法怎么调用，使用哪个运算符？
		4.什么是缺省构造器？
		5.怎么防止缺省构造器丢失？
		6.实例变量在类加载是初始化吗？实例变量在什么时候初始化？
#### 9、封装
1、面向对象的三大特征：
	封装继承多态
	有了封装，才有继承，有了继承，才能说多态。
	2、面向对象的首要特征：封装 。什么是封装？有什么用？
	现实生活中有很多现实的例子都是封装的，例如：手机，电视机，笔记本电脑，照相机，这些都是外部有一个坚硬的壳儿。封装起来，保护内部的部件。保证内部的部件是安全的。另外封装了之后，对于我们使用者来说，我们是看不见内部的复杂结构的，我们也不需要关心内部有多么复杂，我们只需要操作外部壳儿上的几个按钮就可以完成操作。
	封装的作用有两个：保证内部结构的安全。屏蔽复杂，暴露简单。
	在代码级别上，封装有什么用？
	一个类体当中的数据，假设封装之后，对于代码的调用人员来说，不需要关心代码的复杂实现，只需要通过一个简单的入口就可以访问了。另外，类体中安全级别较高的数据封装起来，外部人员不能随意访问，来保证数据的安全性。	
	3、怎么进行封装，代码怎么实现？
		第一步：属性私有化（使用private关键字进行修饰。）
		第二步：对外提供简单的操作入口。1个属性对外提供两个set和get方法。外部程序只能通过set方法修改，只能通过get方法读取，可以在set方法中设立关卡来保证数据的安全性。
		set和get方法都是实例方法，不能带static。
		不带static的方法称为实例方法，实例方法的调用必须先new对象。
		set和get方法写的时候有严格的规范要求：（大家要按照规矩来）
			set方法长这个样子：
				public void set+属性名首字母大写(1个参数){
					xxx = 1个参数;
				}
			get方法长这个样子：
				public 返回值类型 get+属性名首字母大写(无参){
					return xxx;
				}
		有static关键字修饰的方法怎么调用：类名.方法名（实参）
  没有static关键字修饰的方法怎么调用：引用.方法名（实参）
#### 10、static关键字
	2.1、static修饰的统一都是静态的，都是类相关的，不需要new对象。直接采用“类名.”访问。
	2.2、当一个属性是类级别的属性，所有对象的这个属性的值是一样的，建议定义为静态变量。
 2.3、使用static关键字可以定义：静态代码块
         语法是什么？
		static {
			java语句;
			java语句;
		}
	       static静态代码块在什么时候执行呢？类加载时执行。并且只执行一次。静态代码块有这样的特征/特点。
	2.4、注意：静态代码块在类加载时执行，并且在main方法执行之前执行。
	2.5、静态代码块一般是按照自上而下的顺序执行。
	2.6、静态代码块有啥作用，有什么用？
		第一：静态代码块不是那么常用。（不是每一个类当中都要写的东西。）
		第二：静态代码块这种语法机制实际上是SUN公司给我们java程序员的一个特殊的时刻/时机。
		这个时机叫做：类加载时机。
	具体的业务：
		项目经理说了：大家注意了，所有我们编写的程序中，只要是类加载了，请记录一下类加载的日志信息（在哪年哪月哪日几时几分几秒，哪个类加载到JVM当中了）。
		思考：这些记录日志的代码写到哪里呢？
			写到静态代码块当中。
	栈：方法只要执行，会压栈。（局部变量）	堆：new出来的对象都在堆中。垃圾回收器主要针对。（实例变量）
	方法区：类的信息，字节码信息，代码片段。（静态变量）

	方法的代码片段放在方法区，但是方法执行过程当中需要的内存在栈中。
	到目前为止，遇到的所有java程序，有顺序要求的是哪些？
		第一：对于一个方法来说，方法体中的代码是有顺序的，遵循自上而下的顺序执行。
		第二：静态代码块1和静态代码块2是有先后顺序的。
		第三：静态代码块和静态变量是有先后顺序的。
2.7、除了静态代码块之外，还有一种语句块叫做：实例语句块2、实例语句在类加载是并没有执行。
2.8、实例语句语法？
	{
		java语句;
		java语句;
		java语句;
	}
2.9、实例语句块在什么时候执行？
	只要是构造方法执行，必然在构造方法执行之前，自动执行“实例语句块”中的代码。
	实际上这也是SUN公司为java程序员准备一个特殊的时机，叫做对象构建时机。
	2.10到目前为止一个类当中可以出现的：		
类体{
			实例变量;
			实例方法;

			静态变量;
			静态方法;

			构造方法;

			静态代码块;
			实例语句块;

			方法(){
				// 局部变量
				int i = 100;
			}
		}
#### 11、this关键字
        1.1、this是一个关键字，是一个引用，保存内存地址指向自身。
	1.2、this可以使用在实例方法中，也可以使用在构造方法中。
	1.3、this出现在实例方法中其实代表的是当前对象。
	1.4、this不能使用在静态方法中。
	1.5、this. 大部分情况下可以省略，但是用来区分局部变量和实例变量的时候不能省略。
	1.6、this() 这种语法只能出现在构造方法第一行，表示当前构造方法调用本类其他的
	构造方法，目的是代码复用。
	1.7、程序再怎么变化，万变不离其宗，有一个固定的规律：所有的实例相关的都是先创建对象，通过“引用.”来访问。所有的静态相关的都是直接采用“类名.”来访问。总有一些是需要记忆的，在这些记忆的基础之上进行分析。
	大结论：
		只要负责调用的方法a和被调用的方法b在同一个类当中：
			this. 可以省略
			类名. 可以省略
#### 12、继承extends
	3.1、什么是继承，有什么用？
		继承：在现实世界当中也是存在的，例如：父亲很有钱，儿子不用努力也很有钱。
		继承的作用：
			基本作用：子类继承父类，代码可以得到复用。（这个不是重要的作用，是基本作用。）
			主要(重要)作用：因为有了继承关系，才有了后期的方法覆盖和多态机制。
	
	3.2、继承的相关特性
		① B类继承A类，则称A类为超类(superclass)、父类、基类，B类则称为子类(subclass)、派生类、扩展类。
			class A{}
			class B extends A{}
			我们平时聊天说的比较多的是：父类和子类。
			superclass 父类
			subclass 子类
		② java 中的继承只支持单继承，不支持多继承，C++中支持多继承，
		这也是 java 体现简单性的一点，换句话说，java 中不允许这样写代码：
			class B extends A,C{ } 这是错误的。
		③ 虽然 java 中不支持多继承，但有的时候会产生间接继承的效果，
		例如：class C extends B，class B extends A，也就是说，C 直接继承 B，
		其实 C 还间接继承 A。
		④ java 中规定，子类继承父类，除构造方法不能继承之外，剩下都可以继承。
		但是私有的属性无法在子类中直接访问。(父类中private修饰的不能在子类中
		直接访问。可以通过间接的手段来访问。)
		⑤ java 中的类没有显示的继承任何类，则默认继承 Object类，Object类是 
		java 语言提供的根类（老祖宗类），也就是说，一个对象与生俱来就有 
		Object类型中所有的特征。
		⑥ 继承也存在一些缺点，例如：CreditAccount 类继承 Account 类会导致它
		们之间的耦合度非常高，Account 类发生改变之后会马上影响到 CreditAccount 类
	3.3、测试：子类继承父类之后，能使用子类对象调用父类方法吗？
		可以，因为子类继承了父类之后，这个方法就属于子类了。当然可以使用子类对象来调用。
	3.4、在实际开发中，满足什么条件的时候，我可以使用继承呢？
		凡是采用“is a”能描述的，都可以继承。
		例如：
			Cat is a Animal：猫是一个动物
			Dog is a Animal：狗是一个动物
			CreditAccount is a Account：信用卡账户是一个银行账户
			....
		
		假设以后的开发中有一个A类，有一个B类，A类和B类确实也有重复的代码，那么他们两个之间就可以继承吗？不一定，还是要看一看它们之间是否能够使用is a来描述。
			class Customer{
				String name; // 名字
				// setter and getter
			}

			class Product{
				String name; // 名字
				// setter and getter
			}

			class Product extends Customer{
			
			}

			以上的继承就属于很失败的。因为：Product is a Customer，是有违伦理的。
	3.5、任何一个类，没有显示继承任何类，默认继承Object，那么Object类当中有哪些方法呢？老祖宗为我们提供了哪些方法？
		一定要适应看JDK的源代码（多看看牛人写的程序自己才会变成牛人。）先模仿后超越。
		java为什么比较好学呢？是因为Java内置了一套庞大的类库，程序员不需要从0开始写代码，程序员可以
基于这套庞大的类库进行“二次”开发。（开发速度较快，因为JDK内置的这套库实现了很多基础的功能。）
		例如：String是SUN编写的字符串类、System是SUN编写的系统类。这些类都可以拿来直接使用。	
		JDK源代码在什么位置？
			C:\Program Files\Java\jdk-13.0.2\lib\src.zip
		
		你现在能看懂以下代码了吗？
			System.out.println("Hello World!");
			System.out 中，out后面没有小括号，说明out是变量名。
			另外System是一个类名，直接使用类名System.out，说明out是一个静态变量。
			System.out 返回一个对象，然后采用“对象.”的方式访问println()方法。		
		我们研究了一下Object类当中有很多方法，大部分看不懂，其中有一个叫做toString()的，我们进行了测试，发现：
		System.out.println(引用);当直接输出一个“引用”的时候，println()方法会先自动调用“引用.toString()”，然后输出toString()方法的执行结果。
		
#### 13、方法覆盖	
	2.1、什么时候考虑使用方法覆盖？
		父类中的方法无法满足子类的业务需求，子类有必要对继承过来的方法进行覆盖。
	2.2、什么条件满足的时候构成方法覆盖？
		第一：有继承关系的两个类
		第二：具有相同方法名、返回值类型、形式参数列表
		第三：访问权限不能更低。
		第四：抛出异常不能更多。
	2.3、关于Object类中toString()方法的覆盖？
		toString()方法存在的作用就是：将java对象转换成字符串形式。
		大多数的java类toString()方法都是需要覆盖的。因为Object类中提供的toString()
		方法输出的是一个java对象的内存地址。
		至于toString()方法具体怎么进行覆盖？格式可以自己定义，或者听需求的。（听项目要求的。）
	2.4、方法重载和方法覆盖有什么区别？
		方法重载发生在同一个类当中。方法覆盖是发生在具有继承关系的父子类之间。方法重载是一个类中，方法名相同，参数列表不同。方法覆盖是具有继承关系的父子类，并且重写之后的方法必须和之前的方法一致：方法名一致、参数列表一致、返回值类型一致。
	2.5、回顾一下方法重载！！！！		什么时候考虑使用方法重载overload？
			当在一个类当中，如果功能相似的话，建议将名字定义的一样，这样
			代码美观，并且方便编程。	
		什么条件满足之后能够构成方法重载overload？
			条件一：在同一个类当中
			条件二：方法名相同
			条件三：参数列表不同（个数、顺序、类型）
	--------------------------------------------------------------------------------
	这里还有几个注意事项：（这几个注意事项，当学习了多态语法之后自然就明白了！）
		注意1：方法覆盖只是针对于方法，和属性无关。
		注意2：私有方法无法覆盖。
		注意3：构造方法不能被继承，所以构造方法也不能被覆盖。
		注意4：方法覆盖只是针对于“实例方法”，“静态方法覆盖”没有意义。
#### 14、多态
	3.1、向上转型和向下转型的概念。
		向上转型：子--->父 (upcasting)
			又被称为自动类型转换：Animal a = new Cat();
		向下转型：父--->子 (downcasting)
			又被称为强制类型转换：Cat c = (Cat)a; 需要添加强制类型转换符。
			什么时候需要向下转型？
				需要调用或者执行子类对象中特有的方法。
				必须进行向下转型，才可以调用。
			向下转型有风险吗？
				容易出现ClassCastException（类型转换异常）
			怎么避免这个风险？
				instanceof运算符，可以在程序运行阶段动态的判断某个引用指向的对象是否为某一种类型。养成好习惯，向下转型之前一定要使用instanceof运算符进行判断。不管是向上转型还是向下转型，首先他们之间必须有继承关系，这样编译器就不会报错。
3.2、什么是多态。
		多种形态，多种状态，编译和运行有两个不同的状态。
		编译期叫做静态绑定。
		运行期叫做动态绑定。
		Animal a = new Cat();
		// 编译的时候编译器发现a的类型是Animal，所以编译器会去Animal类中找move()方法
		// 找到了，绑定，编译通过。但是运行的时候和底层堆内存当中的实际对象有关
		// 真正执行的时候会自动调用“堆内存中真实对象”的相关方法。
		a.move();

		多态的典型代码：父类型的引用指向子类型的对象。（java中允许这样写代码！！！）
	3.3、什么时候必须进行向下转型？
		调用子类对象上特有的方法时。
 	3.4、多态在开发中有什么作用？	非常重要：五颗星。。。。（多态你会天天用，到处用！！！！）
	        多态在开发中的作用是：降低程序的耦合度，提高程序的扩展力。
		public class Master{
			public void feed(Dog d){}
			public void feed(Cat c){}
		}
		以上的代码中表示：Master和Dog以及Cat的关系很紧密（耦合度高）。导致扩展力很差。

		public class Master{
			public void feed(Pet pet){
				pet.eat();
			}
		}
		以上的代表中表示：Master和Dog以及Cat的关系就脱离了，Master关注的是Pet类。
		这样Master和Dog以及Cat的耦合度就降低了，提高了软件的扩展性。	
		面向对象的三大特征：
		封装、继承、多态真的是一环扣一环。有了封装，有了这种整体的概念之后。对象和对象之间产生了继承。有了继承之后，才有了方法的覆盖和多态。
	这里提到了一个软件开发原则：
		七大原则最基本的原则：OCP（对扩展开放，对修改关闭）目的是：降低程序耦合度，提高程序扩展力。面向抽象编程，不建议面向具体编程。
	3.5、怎么避免ClassCastException异常的发生？？？		/*	
			新的内容，运算符：
				instanceof （运行阶段动态判断）
			第一：instanceof可以在运行阶段动态判断引用指向的对象的类型。
			第二：instanceof的语法：
				(引用 instanceof 类型)
			第三：instanceof运算符的运算结果只能是：true/false
			第四：c是一个引用，c变量保存了内存地址指向了堆中的对象。
				假设(c instanceof Cat)为true表示:
					c引用指向的堆内存中的java对象是一个Cat。
				假设(c instanceof Cat)为false表示:
					c引用指向的堆内存中的java对象不是一个Cat。
			
			程序员要养成一个好习惯：
				任何时候，任何地点，对类型进行向下转型时，一定要使用
				instanceof 运算符进行判断。（java规范中要求的。）
				这样可以很好的避免：ClassCastException
3.6、解释之前遗留的问题
	私有方法无法覆盖。方法覆盖只是针对于“实例方法”，“静态方法覆盖”没有意义。（这是因为方法覆盖通常和多态联合起来）
	总结两句话：私有不能覆盖。静态不谈覆盖。
	在方法覆盖中，关于方法的返回值类型。
		什么条件满足之后，会构成方法的覆盖呢？
			1、发生具有继承关系的两个类之间。
			2、父类中的方法和子类重写之后的方法：具有相同的方法名、相同的形式参数列表、相同的返回值类型。
		
	学习了多态机制之后：“相同的返回值类型”可以修改一下吗？对于返回值类型是基本数据类型来说，必须一致。对于返回值类型是引用数据类型来说，重写之后返回值类型可以变的更小（但意义不大，实际开发中没人这样写。）。

15、super关键字
	1、super能出现在实例方法和构造方法中。super的语法是：“super.”、“super()”super不能使用在静态方法中。super. 大部分情况下是可以省略的。super.什么时候不能省略呢？父类和子类中有同名属性，或者说有同样的方法，想在子类中访问父类的，super. 不能省略。**super() 只能出现在构造方法第一行，**通过当前的构造方法去调用“父类”中的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。this()和super() 不能共存，它们都是只能出现在构造方法第一行。
	super的使用：
		super.属性名				【访问父类的属性】
		super.方法名(实参)		【访问父类的方法】
		super(实参)					【调用父类的构造方法】

	2、“this.”和“super.”大部分情况下都是可以省略的。	
        this. 什么时候不能省略？
		public void setName(String name){
			this.name = name;
		}
	super. 什么时候不能省略？
		父中有，子中又有，如果想在子中访问“父的特征”，super. 不能省略。






























