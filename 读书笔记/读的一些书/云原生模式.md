:::info
💡  根据 [遗忘曲线](https://baike.baidu.com/item/%E9%81%97%E5%BF%98%E6%9B%B2%E7%BA%BF/7278665?fr=aladdin)：如果没有记录和回顾，6天后便会忘记75%的内容
      读书笔记正是帮助你记录和回顾的工具，不必拘泥于形式，其核心是：记录、翻看、思考
:::

| **书名** | 云原生模式 |
| --- | --- |
| **作者** | Cornelia Davis |
| **状态** | 待开始 阅读中 已读完 |
| **简介** | 掌握云原生相关理论、架构、方法和工具，了解云原生应用程序的思维模式，以及支持期构建的模式、实践和工具。通过对“云原生”的学习思考及应用，提升交付水平，养成读书分享习惯。结合实际工作，思考如何改进提高、为公司创造更大的价值。 |

## 思维导图
> 用思维导图，结构化记录本书的核心观点。

![](https://images.cherryfloris.eu.org/2022/1655276384470-e8a584c4-9ae0-4352-b640-09c0355b231b.jpeg)
# 云原生应用程序的各种模式
活性探测——定期调用应用程序的健康端点，如果健康检查失败，则重新创建一个应用实例。
# 第一部分 云原生上下文
## 第1章 什么是“云原生”
### 现代软件用户需求
持续的可用性、频繁发布新版本以实现不断演进、易于伸缩和智能化
### 云原生软件
#### 定义
云原生软件是高度分布式的，必须在一个不断变化的环境中运行，而且自身也在不断地发生变化。
#### 核心特征
高度分布式和不断变化。
### 云原生
云原生是一种**构建和运行应用程序的方法**，是一套技术体系和方法论。云原生（CloudNative）是一个组合词，Cloud+Native。Cloud表示应用程序位于云中，而不是传统的数据中心；Native表示应用程序从设计之初即考虑到云的环境，原生为云而设计，**在云上以最佳姿势运行**，充分利用和发挥云平台的弹性+分布式优势。
### 云原生软件模型中的关键实体：应用程序、数据和交互

- 应用：水平可伸缩，多实例部署、在云原生背景下的应用生命周期管理
- 数据：打破单体的数据设计模式，提供分布式的数据架构，满足敏捷和弹性诉求；同时，公共实体在多个数据库实例之间的一致性问题需要重点考虑；另外数据状态在各个数据成员之间同步也是关键部分
- 交互：重试等服务治理模式、服务组合及适合云原生场景的通用协议、合适的路由系统。

“云"是指软件在哪里运行，而“云原生"指的是软件如何运行。
### 什么不是云原生

1. 非分布式，不需要云和云原生应用的场景
2. 亘古不变的软件使用场景
3. 强一致性要求（实时）的应用场景
4. 存量的、衰退期的应用

云原生并不是非此即彼的架构；一些软件可以采用许多新的云原生架构模式，一些软件可以仍然继续使用较老的架构，还有一些软件可以采用混合架构（新旧架构结合)
给出了云原生的定义，并详细分析了云原生软件的特点和组成要素，对于理解云原生来说非常有帮助。

---

## 第2章 在生产环境中运行云原生应用程序
### 1. 面对的障碍

1. 碎片化的变化：环境差异带来的变化、部署构建发生的变化
2. 有风险的部署：部署过程中多个部件的配合、衔接和回退的管控
3. 认为变化是例外
4. 生产环境的不稳定
### 2.解决的方法
1.CD：Continuous Delivery 持续部署。

- 提早抢占市场
- 及时获取市场反馈
- 及时进行变更

2.可重复性：有助于系统部署和提高系统的稳定性

- 控制部署软件的环境（标准的镜像、上下文的依赖）
- 控制软件
- 控制软件的发布过程

3.安全部署

- 并行部署和版本化的服务：rolling upgrad，滚动升级是安全部署的核心
- 进行必要的远程监控： 可监控和运营
- 灵活的路由： 通过灵活的路由机制，将实验范围控制在有限的阵地

---

## 第3章 云原生软件平台
###  云平台发展历史简介
云计算—>谷歌微软—>云原生平台
###  云原生平台的基础功能

- 创建应用程序的实例
- 监视应用程序的健康状况
- 在基础设施上分布应用程序的实例:为容器分配IP地址
- 动态路由到应用程序的实例配置注入
- 其他更多功能
###  容器的基本知识
当我提到容器这个术语时，很可能你会立即想到“Docker”。但是我想做的，是把容器中的关键概念也抽象出来，这样你可以更容易地将这些能力与云原生软件联系起来。

- 从基本层面上说，容器其实是一个使用底层机器功能(例如，底层的操作系统)的计算环境。通常，多个容器会运行在一台机器(例如，服务器)上，机器可以是实际的也可以是虚拟的。多个容器之间是彼此隔离的。
- 从较高层面上说，它们有点像虚拟机(VM)，即一个运行在共享资源上的独立计算环境。但是，容器比虚拟机更加轻量级，创建容器的时间比创建虚拟机的时间低几个数量级，消耗的资源也更少。

前面已经提到，在一台主机上运行的多个容器会共享主机的操作系统，但仅此而已。应用程序所需的其他运行时环境都运行在容器中(没错，你的应用程序会在容器中运行)。
#### 容器有关的几个知识点:

- 基础设施上会有多台主机:
- 主机上运行着多个容器;
- 应用程序会使用已安装在容器中的操作系统和运行时环境。
### ![image.png](https://images.cherryfloris.eu.org/2022/1655275630434-c0dda096-7f79-4599-baab-d5c19a8e551a.png)
### 
 如何在整个软件开发生命周期中使用平台
### 安全性、合规性和变更控制
![image.png](https://images.cherryfloris.eu.org/2022/1655276464151-c4712b96-a35c-4ff8-9eb6-1327d818af45.png)

---

> 正如前面己经说过的，云原生应用程序会部署多个副本，这也是为了适应变化和扩大规模。如果你在一个底层是传统基础设施的平台上运行现代应用程序，那么必须通过暴露的传统数据中心抽象（例如主机、存储卷和网络），来获取或者访问日志。

### 问题：
既然云原生应用程序会部署多个副本，他保证应用不间断的运行同时，是否占用了大量的资源？
答：云原生平台的可伸缩性  会根据应用程序来分配内存  现在的应用程序很强大 根本不需要担心资源问题

# 第二部分 云原生模式
## 第4章 事件驱动微服务：不只是请求/响应
交代了云原生软件实现的障碍，其主要实现是微服务，但各个微服务的紧密连接导致了形成一个庞大的单体系统的现象，引出对请求/响应的编程模型的思考。
### 命令式编程方式
用户向服务发送一个请求，期待一个响应，而在微服务中一个请求将向其下游服务扩散数个请求，而其中一个服务出现请求失败就会导致用户得不到期望的响应，服务的稳定性大大降低。
### 事件驱动的编程模型
触发代码执行的实体并不期望任何类型的响应，代码执行会产生一个结果，可能进一步触发其他的代码执行，微服务的触发事件与其他微服务的行为无关，互相没有依赖或很少依赖，。
搭建一个微服务来对比请求/响应和事件驱动这两种编程模型，阐明事件驱动架构的目的，是为了解决系统过于紧耦合的问题，通过事件传递让微服务感知变化并执行代码，在不依赖于其他微服务生成的结果，也可能产生新的事件。当生成的结果使得数据变化的时候，使用异步方式聚合数据，异步在分布式系统中式非常重要的。
### 命令查询职责分离模式
核心思想就是将命令和查询分离开来，这种思想也适用于非事件驱动的架构设计，但在事件驱动的系统中起着非常重要的作用。
两种编程模型的通性，采取特定手段达到相同目的。

在进行云原生架构设计中根据业务诉求，分析请求/响应和事件驱动这两种编程模型的特点，适当应用。
## 第5章 应用程序冗余：水平伸缩和无状态
交代了云原生软件的核心思想，即冗余。理想的情况下，水平伸缩的若干个应用程序实例在相同的输入的情况下产生相同的结果，但在实际场景中面临诸多挑战，例如身份验证。
### 水平伸缩概念
通过增加或减少应用程序的容量（实例数量）来改变系统能够处理的请求数量，这就使得结合水平伸缩和基于微服务的架构的系统在系统的整体资源消耗方面获得极大的灵活性。
### 有状态模式
常见的状态就是会话状态，然后通过云原生平台实操复现了无法正确处理身份认证的问题，因为令牌信息存储在水平伸缩的每个应用程序实例内，导致用户在请求不同实例时得到了不同的结果。
### 黏性会话
场景：为解决无法正确处理身份认证的问题，即用户第一次请求时记住会话ID，在后续的请求中通过负载均衡器处理识别会话ID，用户请求始终负载到同一个实例，这种实现模式不符合云原生架构设计。
### 应用程序的有状态和无状态区别
将系统设计成多个部分，一部分服务解决系统的规模的弹性，另一部分服务处理更困难的数据管理任务。针对无法正确处理身份认证的问题，给出了令牌存储的解决方案，将有状态的应用程序变得无状态，当然应用程序拓扑变得更复杂。
水平伸缩指在集群中添加或减少应用实例，无状态指每个实例不保留业务相关的数据；无状态是实现灵活的水平伸缩的必要条件。
> 想象如下场景，一个认证服务器是多实例的，它将用户的token保存在本地内存中，那么当该实例宕机时，即使负载均衡可以将请求路由到其它正常的实例中，但那个实例并没有用户token，因此用户需要重新登录，无疑会影响用户体验。
> 构建专门存储状态的服务，比如redis，认证服务只需将token保存在redis中，并且每个实例都访问同一个redis服务获取状态，就能实现认证服务的无状态了，服务集群的水平伸缩也可以放心地由平台完成。

云原生部署冗余实例，如何使这些实例成为无状态，如何让其与指定的有状态的服务进行关联
云原生软件环境中，应将应用程序设计成有状态和无状态的多个服务，有状态的服务保证可靠性，而无状态的服务充分发挥云原生的优势，在系统资源消耗上发挥灵活性。
## 第6章 应用程序配置：不只是环境变量
介绍了应用程序的配置需求，包括请求历史、系统环境和应用程序配置，要让应用程序实例是无状态的，就要确保消除这些影响。
要做到应用程序在零停机情况下做到动态伸缩和更新基础设施，应管理应用程序配置，在正确的时间、以合理的方式将配置注入到应用程序中。
### 动态伸缩——增加和减少应用程序实例的数量
应用程序实例的增减，应在不影响业务发布前提下完成，目的是实现应用程序实例的业务无关性上线配置。我们一定希望任何情况下我们扩容的应用实例的拿来就可以用的，而不是等人工是进入应用实例配置。

变化是一定的，而不是例外，放弃控制权能够让系统更加独立地运行。对于软件部署拓扑等系统配置，手工配置需要大量的工作，Kubernetes负责部署和管理应用程序实例，获取环境变量为应用程序提供配置值。
### 配置服务管理应用程序的配置数据
具备持久化、控制访问、自动配置、版本控制、敏感数据安全管理的特点，为属性文件中定义的变量提供绑定的参数值，并依据应用程序的生命周期规律注入正在运行的应用程序。
云原生应用程序的无状态目标的实现，完善的配置数据管理必不可少，要求配置数据管理像代码一样同等重要。
## 第7章 应用程序生命周期：考虑不断的变化
### 应用程序生命周期的定义
软件开发生命周期(SDLC)：关于软件从开发到交付过程中所经历的各个阶段--从设计，到开发，然后到通过单元测试、集成测试，最终交付到生产环境。
应用程序的生命周期：应用程序已经准备好进行生产部署之后，要经历的所有阶段。它的核心关注点不是软件开发或者管理，而是应用程序本身的状态。应用程序是否已经部署?是否还在运行?是否停止(因为故障或人为停止)?虽然将部署中的应用程序认为是SDLC的一部分是很自然的，但是这里关注的重点是应用程序的运行状态。
### 零停机时间升级：蓝/绿升级和滚动升级
#### 蓝/绿升级
首先，有一个负载均衡器为所有蓝色实例分配流量。在下一步中，要部署相同数量的新的绿色版本实例，但是仍将所有生产环境的流量路由到蓝色实例。然后，可以向绿色实例分配一些流量来检查它们运行是否正常，通过验证之后，就可以将所有流量从蓝色版本切换到绿色版本。
注意从应用程序设计的角度来看，蓝/绿升级比滚动升级更加简单，原因在于前者同一时间只能运行一个应用程序的版本。
#### 滚动升级
对于运行中的应用程序来说，滚动升级可以实现零停机时间升级，并且就像蓝/绿升级一样，在完成升级时，应用程序的所有流量会被路由到新的版本。然而，
两者的升级过程有明显差异。
一开始，所有的流量都是在应用程序当前版本的多个实例之间进行负载均衡的。在升级过程中，流量会改为在应用程序原始版本的实例和新版本的实例之间进行负载均衡。也就是说，应用程序的多个版本会同时承接流量!在确认第一组新版本的实例运行良好之后，可以继续升级下一组，以此类推。滚动升级完成时，所有旧版本的应用程序实例会被新的版本取代。
**只有当一个应用程序的多个实例可以同时支持不同的配置时，才能使用滚动升级的部署方式。否则，必须使用蓝/绿升级的部署方式。两者都可以在零停机时间内完成。**
#### 并行部署
        并行部署即同时部署多个版本的应用程序，不同版本的应用将长期存在，它可能是2个版本也可以是更多的版本，理论上只要支持我们可以同时创建无数个并行发布的应用。
         我猜测大家对这种部署模式最不看好，但我几乎可以肯定大多数互联网企业都是这样做的，他们为不同用户提供不同版本的应用，虽然这种软件设计要求最高，因为需要保证该部署模式对消费者透明为消费者提供一致性的服务，前端负载均衡的调度策略也需要额外的会话保持设计但却为企业带来了与众不同的的业务模式。我举个例子，某互联网企业设计了3个不同的广告推广算法，通过一段时间的测量通过适当的控制变量推广，我们可以轻而易举的量化不同广告推广算法的回报率，从而为广告主以及广告推广平台带来双赢。
### 密码轮换模式
一个精心设计的密码轮换模式，可以通过滚动升级的方式来实现。
1）密码在程序启动时配置
2）为了支持0停机时间的密码更换，服务允许有多个密码
        我们还是以最初的网站聚合服务为例，帖子关系服务需要调用帖子服务，我们的最终目标是更新帖子关系服务的调用密码即从“first secret”切换到“second secret”，与此同时业务不能中断。
        在整个变更流程的第一步我们需要先升级生产者，为生产者注入1套新密码即消费者更新后的调用密码，第一步完成后需要注意，变更后的生产者需要支持多密码适配，即生产者可以匹配消费者提交的密码中查询本地密码数据库，只要任意密码匹配即可成功访问本地服务。
   变更第二步，消费者升级本地代码为变更后状态，即将调用密码更新为“second secret”。最后一步，我们再次更新生产者，即移除原有调用密码，以便完成整个密码轮换。
### 应用程序生命周期和故障排除
#### 云原生应用的特点
不断的被创建，不断的被销毁，虽然违背了“稳定即是好事，变换即是坏事”传统观念，但在云计算中变化是不可避免的甚至可以带来一直新的稳定。
在应用实例开启、关闭时需要告知上下游的消费者与生产者。在广播依赖关系时还需要知道我们面对的是不可靠的网络、高度分布式的应用实例组件。
无论应用是否正常，都需要持续不断的探测，循环比较期望状态与实际状态，如果发现期望状态与实际状态不一致，需要考虑通过冗余机制对其进行修复。
为保证云原生应用在不断变化中保持稳定，需要给云原生应用赋能新的特性，即应用程序生命周期状态的可见性
处理临时运行环境：可预测性确保了检测的准确性，或者我们可以这样说，正是因为应用响应结果的可预测我们才能为应用监控配置正确的监控参数。正是因为我们知道应用实例运行正常的响应结果让我们得以预测其异常行为下的响应结果。
**如何做到容器的可预测性、重复性？**

- 不允许修改单个容器镜像（禁止SSH到容器内）
- 重视日志、指标的获取（将日志视为事件流）

任何情况下都不允许修改单个容器的镜像，因为容器始终在变化，上一秒一个正在对外发布的容器实例，下一秒可能就会被销毁，修改单个容器是毫无意义的，如果希望纠正某个错误请直接修改容器基镜像。当然，为了保证可以找出导致错误的蛛丝马迹，请务必重视日志的地位，将容器的所有动作、指标通过日志传递出来，保证容器的所有操作有迹可循。
### 应用程序健康检查
无服务计算
## 第8章 如何访问应用程序：服务、路由和服务发现
(1)可以用一个简单的抽象将客户端和依赖服务之间松耦合。
(2)有两种主要的负载均衡方法—集中式（或者服务端）和客户端。每种方法都有各自的优点和缺点。
(3)负载均衡器的配置必须是动态且高度自动化的，因为在云原生环境中，流量被路由到的实例比过去变化的频率大得多。
(4)诸如DNS之类的名称服务是服务发现协议的核心，该协议允许客户端在不断变化的网络拓扑中找到相关服务。
(5)在使用域名服务时，作为一名开发人员，你必须考虑到名称到IP地址的映射表是最终一致的，你必须考虑到映射记录可能已经过期的情况。
(6)使用一种服务发现协议可以让软件部署变得更有弹性
## 第9章 交互冗余：重试和其他控制循环
> 请求重试的基本模式很简单：应用程序向远程服务发出请求，如果在合理的时间内没有接收到响应，将再次尝试

(1)重试一个超时请求可以降低本来会通过系统传播的错误。
(2)如果处理不当，即使修复了连接性的问题，排队中的重试请求也会使系统过载。
(3)正确配置的重试既可以显著降低重试风暴的风险，又可以在不太严重的停机事故中提供巨大的好处。
(4)只有在安全的情况下才使用重试，是一名开发人员应该承担的责任。
(5)你不仅应该养成实现服务的核心逻辑的习惯，还应该养成在意外情况下实现回退逻辑的习惯。
(6)重试只是一种控制循环模式的例子。
(7)对于组成云原生软件的分布式系统，控制循环是一项必不可少的技术。
## 第10章 前沿服务：断路器和API网关
断路器
在软件中，断路器的运行方式基本相同。当负载过高时，断路器会打开并阻止流量通过。但是它有两个不同之处。首先，用来检测何时应打开断路器的机制是基于实际的故障，而不是对可能的故障的预测（你肯定不希望电路在检测到小火苗后才会跳闸）。其次，软件中的断路器通常具有内置的自我修复机制（这与让人类在黑暗的房屋中找到配电板，并手动翻转断路器的方式不同）。
api网关
开源和商业API网关比微服务和基于云的架构兴起得还要早。例如，Apigee（自被Google收购）和Mashery（被Intel收购，然后出售给TIBCO）都是在20世纪00年代初期成立的公司，都专注于开发API网关。API网关在软件架构中扮演的角色始终如本章标题所述，始终位于实现的最前面，并且提供了大量的服务
服务网格
我们不必一步就实现服务网格（Service Mesh），从一个在服务网格中起核心作用的原语开始。然后，我将继续介绍服务网格及其在云原生软件架构中扮演的日益重要的角色。
(1)在服务的前端设计了许多模式，用来控制与该服务的交互方式。
(2)断路器是用来防止服务过载（包括重试风暴所产生的流量）的基本模式。
(3)API网关早于云原生架构出现，如今已经发展得可以很好地适应高度分布式化、不断变化的软件部署环境。
(4)应用于交互的客户端和服务端的模式，都可以封装并作为一个挎斗代理被部署。
(5)服务网格为挎斗代理添加了一个管理平面，该管理平面允许运维人员控制安全性，提供可观察性，并允许配置组成云原生软件的服务/应用程序的集合。
## 第11章 故障排除：如同大海捞针
(1)必须主动将度量指标和日志从执行服务的运行时环境中取出，因为在服务遇到故障或者升级后，这些执行环境通常会变得不可用。服务的执行环境应被视为短暂的。
(2)聚合来自多个服务实例的日志对于可观察性很重要。通常首选按时间顺序来处理不同服务的日志。
(3)可观察性信息、日志、指标和跟踪数据的收集可以放在挎斗代理中实现，这使得应用程序可以专注于业务逻辑，并将运维需求集中到服务网格中。
(4)完善的分布式跟踪技术及其实现，为深入了解分布式应用程序的运行状况和性能提供了宝贵的洞察能力。
(5)本书前面介绍的许多模式都可以用来提供所需的可观察性。应用程序配置、应用程序生命周期、服务发现、网关和服务网格都有各自的作用。
### 11.1 应用程序日志
日志 管理应该完全与应用程序代码无关。
应用程序代码应该负责记录内容，而日志出现的位登应该完全由应用程 序部署来控制，而不是由应用程序本身来决定。
### 11.2 应用程序度量指标
与日志一样， 有一个关键的问题， 即使在运行时环境不可用之后， 你也要确保指标数据可用。 你要从应用程序和运行时上下文中获取指标， 有两种基本方法可以仗用， 即基于拉的模式和基于推的模式。
#### 从云原生应用程序中获取指标
在基于拉的方法中，度量指标聚合器会作为一个收集器， 从每个应用程序实例中收集请求指标数据， 并将这些指标存储在时序数据库中，它有点像刚才看到的对/actuator/metrics端点的curl请求，收集器作为一个客户端发出一个请求，而应用程序实例返回所需的数据。
![image.png](https://images.cherryfloris.eu.org/2022/1657262901920-32b3edc0-3d42-440c-a93f-217bf037913c.png)
#### 从云原生应用程序中推送指标
拉换式的一个替代方案是基于推的模式，其中，每个应用实例负责按固定时间 间隔将指标发给指标聚合器。作为一个应用程序的开发人员，你 可能不愿承担发送指标数据的责任，因为该工作脱离了为客户和组织带来价值的 核心业务逻辑。不过，好消息是，就像本书中谈到的许多跨领域的关注点一样，生成和交付指标的许多工作都可以由我们信任的框架和平台负责。
实现基于推模式的指标框架时，通常会使用一个代理来负责收集指标，并将其发给指标聚合器。这个代理通常会被作为POM或者Gradle构建文件中的一个依赖项，被编译到应用程序的二进制文件中。由于应用程序和代理所处的环境是不断变化的， 所以棘手的是在部署过程和系统管理期间如何正确地配置该代理．
### 11.3分布式跟踪
当所有的代码都运行在同一进程环境中时，我们可以使用完善的工具来跟踪应用程序的执行流程并进行故障排除。源代码级别的调试可以在方法之间跳转，并且在正确配置后，甚至可以进入所引用的库的代码（不是你编写的代码）。发生异常时， 打印到控制台或者日志的调用堆栈伈息可以显示出调用的顺序，这通常有助于问题的诊断。
但是，在云顶生环境中的话求调用会导致一系列的下游诸求，这些下游诸求通常会运行在进程外，实际上，它们通常运行在完全不同的运行时环境中（在不同的容器中或者主机上）。如何查看调用堆栈，或者了解分布式环境中应用程序的调用 结果呢？分布式跟踪是行业中并迫使用的一种技术，在其背后有可靠的工具支撑．
准确地说，分布式跟踪解决的是如何跨多个分布式组件来跟踪程序流的问题。 这是我们能够洞悉对Netflix主页的一次访问会产生大呈下游诸求的原因。
## 第12章 云原生数据：打破数据单体
(1)当为微服务提供一个数据库来存储其所需的数据时，能显著提高自治性。这会让系统整体具有更好的弹性。
(2)尽管在许多情况下有缓存总比没有好，但是使用缓存来填充本地数据库充满了挑战。缓存不适合用于数据频繁变更的场景。
(3)通过事件主动将数据变更推送到本地的数据存储，是一种更好的方法。
(4)尽管我们生产和消费的实体是事件而不是消息，但是该技术的基础仍然是我们熟悉的发布/订阅模式。
(5)将事件日志作为数据的唯一真实来源，所有服务的本地数据库仅保留投射数据，这样可以让运行在高度分布式、不断变化的环境中的云原生软件，实现数据上的一致性。
## 
